// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ledgerwatch/erigon/zk/syncer (interfaces: IEtherman)
//
// Generated by this command:
//
//	mockgen -typed=true -destination=./mocks/etherman_mock.go -package=mocks . IEtherman
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	big "math/big"
	reflect "reflect"

	ethereum "github.com/ledgerwatch/erigon"
	common "github.com/ledgerwatch/erigon-lib/common"
	types "github.com/ledgerwatch/erigon/core/types"
	gomock "go.uber.org/mock/gomock"
)

// MockIEtherman is a mock of IEtherman interface.
type MockIEtherman struct {
	ctrl     *gomock.Controller
	recorder *MockIEthermanMockRecorder
}

// MockIEthermanMockRecorder is the mock recorder for MockIEtherman.
type MockIEthermanMockRecorder struct {
	mock *MockIEtherman
}

// NewMockIEtherman creates a new mock instance.
func NewMockIEtherman(ctrl *gomock.Controller) *MockIEtherman {
	mock := &MockIEtherman{ctrl: ctrl}
	mock.recorder = &MockIEthermanMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIEtherman) EXPECT() *MockIEthermanMockRecorder {
	return m.recorder
}

// BlockByNumber mocks base method.
func (m *MockIEtherman) BlockByNumber(arg0 context.Context, arg1 *big.Int) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BlockByNumber", arg0, arg1)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BlockByNumber indicates an expected call of BlockByNumber.
func (mr *MockIEthermanMockRecorder) BlockByNumber(arg0, arg1 any) *MockIEthermanBlockByNumberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlockByNumber", reflect.TypeOf((*MockIEtherman)(nil).BlockByNumber), arg0, arg1)
	return &MockIEthermanBlockByNumberCall{Call: call}
}

// MockIEthermanBlockByNumberCall wrap *gomock.Call
type MockIEthermanBlockByNumberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanBlockByNumberCall) Return(arg0 *types.Block, arg1 error) *MockIEthermanBlockByNumberCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanBlockByNumberCall) Do(f func(context.Context, *big.Int) (*types.Block, error)) *MockIEthermanBlockByNumberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanBlockByNumberCall) DoAndReturn(f func(context.Context, *big.Int) (*types.Block, error)) *MockIEthermanBlockByNumberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CallContract mocks base method.
func (m *MockIEtherman) CallContract(arg0 context.Context, arg1 ethereum.CallMsg, arg2 *big.Int) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CallContract", arg0, arg1, arg2)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CallContract indicates an expected call of CallContract.
func (mr *MockIEthermanMockRecorder) CallContract(arg0, arg1, arg2 any) *MockIEthermanCallContractCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CallContract", reflect.TypeOf((*MockIEtherman)(nil).CallContract), arg0, arg1, arg2)
	return &MockIEthermanCallContractCall{Call: call}
}

// MockIEthermanCallContractCall wrap *gomock.Call
type MockIEthermanCallContractCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanCallContractCall) Return(arg0 []byte, arg1 error) *MockIEthermanCallContractCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanCallContractCall) Do(f func(context.Context, ethereum.CallMsg, *big.Int) ([]byte, error)) *MockIEthermanCallContractCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanCallContractCall) DoAndReturn(f func(context.Context, ethereum.CallMsg, *big.Int) ([]byte, error)) *MockIEthermanCallContractCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FilterLogs mocks base method.
func (m *MockIEtherman) FilterLogs(arg0 context.Context, arg1 ethereum.FilterQuery) ([]types.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterLogs", arg0, arg1)
	ret0, _ := ret[0].([]types.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FilterLogs indicates an expected call of FilterLogs.
func (mr *MockIEthermanMockRecorder) FilterLogs(arg0, arg1 any) *MockIEthermanFilterLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterLogs", reflect.TypeOf((*MockIEtherman)(nil).FilterLogs), arg0, arg1)
	return &MockIEthermanFilterLogsCall{Call: call}
}

// MockIEthermanFilterLogsCall wrap *gomock.Call
type MockIEthermanFilterLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanFilterLogsCall) Return(arg0 []types.Log, arg1 error) *MockIEthermanFilterLogsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanFilterLogsCall) Do(f func(context.Context, ethereum.FilterQuery) ([]types.Log, error)) *MockIEthermanFilterLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanFilterLogsCall) DoAndReturn(f func(context.Context, ethereum.FilterQuery) ([]types.Log, error)) *MockIEthermanFilterLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HeaderByNumber mocks base method.
func (m *MockIEtherman) HeaderByNumber(arg0 context.Context, arg1 *big.Int) (*types.Header, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeaderByNumber", arg0, arg1)
	ret0, _ := ret[0].(*types.Header)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HeaderByNumber indicates an expected call of HeaderByNumber.
func (mr *MockIEthermanMockRecorder) HeaderByNumber(arg0, arg1 any) *MockIEthermanHeaderByNumberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeaderByNumber", reflect.TypeOf((*MockIEtherman)(nil).HeaderByNumber), arg0, arg1)
	return &MockIEthermanHeaderByNumberCall{Call: call}
}

// MockIEthermanHeaderByNumberCall wrap *gomock.Call
type MockIEthermanHeaderByNumberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanHeaderByNumberCall) Return(arg0 *types.Header, arg1 error) *MockIEthermanHeaderByNumberCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanHeaderByNumberCall) Do(f func(context.Context, *big.Int) (*types.Header, error)) *MockIEthermanHeaderByNumberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanHeaderByNumberCall) DoAndReturn(f func(context.Context, *big.Int) (*types.Header, error)) *MockIEthermanHeaderByNumberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageAt mocks base method.
func (m *MockIEtherman) StorageAt(arg0 context.Context, arg1 common.Address, arg2 common.Hash, arg3 *big.Int) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageAt", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageAt indicates an expected call of StorageAt.
func (mr *MockIEthermanMockRecorder) StorageAt(arg0, arg1, arg2, arg3 any) *MockIEthermanStorageAtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageAt", reflect.TypeOf((*MockIEtherman)(nil).StorageAt), arg0, arg1, arg2, arg3)
	return &MockIEthermanStorageAtCall{Call: call}
}

// MockIEthermanStorageAtCall wrap *gomock.Call
type MockIEthermanStorageAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanStorageAtCall) Return(arg0 []byte, arg1 error) *MockIEthermanStorageAtCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanStorageAtCall) Do(f func(context.Context, common.Address, common.Hash, *big.Int) ([]byte, error)) *MockIEthermanStorageAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanStorageAtCall) DoAndReturn(f func(context.Context, common.Address, common.Hash, *big.Int) ([]byte, error)) *MockIEthermanStorageAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TransactionByHash mocks base method.
func (m *MockIEtherman) TransactionByHash(arg0 context.Context, arg1 common.Hash) (types.Transaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionByHash", arg0, arg1)
	ret0, _ := ret[0].(types.Transaction)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// TransactionByHash indicates an expected call of TransactionByHash.
func (mr *MockIEthermanMockRecorder) TransactionByHash(arg0, arg1 any) *MockIEthermanTransactionByHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionByHash", reflect.TypeOf((*MockIEtherman)(nil).TransactionByHash), arg0, arg1)
	return &MockIEthermanTransactionByHashCall{Call: call}
}

// MockIEthermanTransactionByHashCall wrap *gomock.Call
type MockIEthermanTransactionByHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanTransactionByHashCall) Return(arg0 types.Transaction, arg1 bool, arg2 error) *MockIEthermanTransactionByHashCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanTransactionByHashCall) Do(f func(context.Context, common.Hash) (types.Transaction, bool, error)) *MockIEthermanTransactionByHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanTransactionByHashCall) DoAndReturn(f func(context.Context, common.Hash) (types.Transaction, bool, error)) *MockIEthermanTransactionByHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TransactionReceipt mocks base method.
func (m *MockIEtherman) TransactionReceipt(arg0 context.Context, arg1 common.Hash) (*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionReceipt", arg0, arg1)
	ret0, _ := ret[0].(*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TransactionReceipt indicates an expected call of TransactionReceipt.
func (mr *MockIEthermanMockRecorder) TransactionReceipt(arg0, arg1 any) *MockIEthermanTransactionReceiptCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionReceipt", reflect.TypeOf((*MockIEtherman)(nil).TransactionReceipt), arg0, arg1)
	return &MockIEthermanTransactionReceiptCall{Call: call}
}

// MockIEthermanTransactionReceiptCall wrap *gomock.Call
type MockIEthermanTransactionReceiptCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIEthermanTransactionReceiptCall) Return(arg0 *types.Receipt, arg1 error) *MockIEthermanTransactionReceiptCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIEthermanTransactionReceiptCall) Do(f func(context.Context, common.Hash) (*types.Receipt, error)) *MockIEthermanTransactionReceiptCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIEthermanTransactionReceiptCall) DoAndReturn(f func(context.Context, common.Hash) (*types.Receipt, error)) *MockIEthermanTransactionReceiptCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
