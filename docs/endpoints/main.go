package main

import (
	"fmt"
	"os"
	"reflect"
	"sort"
	"text/template"
	"unicode"
	"unicode/utf8"

	"github.com/ledgerwatch/erigon/turbo/engineapi"
	"github.com/ledgerwatch/erigon/turbo/jsonrpc"
)

const disclaimer = `DO NOT EDIT THIS FILE.
This document was auto generated by [./main.go](./main.go) based on the interfaces the JSON-RPC server use to expose the public endpoints
For more details read the [./README.md](./README.md)`

type Document struct {
	Disclaimer     string
	EndpointGroups []keyValue
}

type keyValue struct {
	Key   any
	Value any
}

func main() {
	apiInterfaces := []keyValue{
		{"admin", (*jsonrpc.AdminAPI)(nil)},
		{"bor", (*jsonrpc.BorAPI)(nil)},
		{"debug", (*jsonrpc.PrivateDebugAPI)(nil)},
		{"engine", (*engineapi.EngineAPI)(nil)},
		{"erigon", (*jsonrpc.ErigonAPI)(nil)},
		{"eth", (*jsonrpc.EthAPI)(nil)},
		{"graphql", (*jsonrpc.GraphQLAPI)(nil)},
		{"net", (*jsonrpc.NetAPI)(nil)},
		{"otterscan", (*jsonrpc.OtterscanAPI)(nil)},
		{"parity", (*jsonrpc.ParityAPI)(nil)},
		{"trace", (*jsonrpc.TraceAPI)(nil)},
		{"txpool", (*jsonrpc.TxPoolAPI)(nil)},
		{"web3", (*jsonrpc.Web3API)(nil)},
		{"zkevm", (*jsonrpc.ZkEvmAPI)(nil)},
	}

	endpointGroups := []keyValue{}
	for _, apiInterface := range apiInterfaces {
		apiPrefix := apiInterface.Key
		apiInterfaceType := apiInterface.Value

		apiEndpoints := []string{}
		interfaceType := reflect.TypeOf(apiInterfaceType).Elem()
		for methodIndex := 0; methodIndex < interfaceType.NumMethod(); methodIndex++ {
			methodName := interfaceType.Method(methodIndex).Name
			methodName = firstToLower(methodName)
			endpointName := fmt.Sprintf("%s_%s", apiPrefix, methodName)
			apiEndpoints = append(apiEndpoints, endpointName)
		}

		sort.Slice(apiEndpoints, func(i, j int) bool {
			return apiEndpoints[i] < apiEndpoints[j]
		})
		endpointGroup := keyValue{Key: apiPrefix, Value: apiEndpoints}

		endpointGroups = append(endpointGroups, endpointGroup)
	}

	fileName := "endpoints.md"
	fmt.Println(os.Args)
	if len(os.Args) > 1 {
		fileName = os.Args[1]
	}

	f, err := createOrOpen(fileName)
	checkErr(err)

	t := template.Must(template.New("template.md").ParseFiles("template.md"))
	err = t.Execute(f, Document{disclaimer, endpointGroups})
	checkErr(err)
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}

func createOrOpen(name string) (*os.File, error) {
	if _, err := os.Stat(name); err == nil {
		os.Remove(name)
	}
	return os.Create(name)
}

func firstToLower(s string) string {
	r, size := utf8.DecodeRuneInString(s)
	if r == utf8.RuneError && size <= 1 {
		return s
	}
	lc := unicode.ToLower(r)
	if r == lc {
		return s
	}
	return string(lc) + s[size:]
}
